>add by jzf@2020-02-06

# ShowAssistant 

# soarmanual
## Chapter 2 The Soar Architecture

### 2.1 An Overview of Soar

Soar的设计是基于这样一个假设，即所有蓄意的目标导向的行为都可以转换为操作符对状态的选择和应用。状态是一种表示当前解决问题的情况;操作符转换状态(对状态的表示做出改变);目标是解决问题活动的预期结果。

当Soar运行时，它不断尝试应用当前的操作符并选择下一个操作符(一个状态一次只能有一个操作符)，直到达到目标为止。

在SOAR中，`当前状态`包括来自传感器的数据、中间推论的结果、主动目标和主动操作者保存在工作记忆中。工作记忆被组织成对象。对象根据其属性来描述;属性的值可以是子对象，所以状态的描述可以有一个层次结构。(这不必严格
层次结构;例如，没有什么可以阻止两个对象互为“子结构”。)

长期的过程性知识保存在生产记忆中。程序性的知识指定在工作记忆中如何应对不同的情况，可以看作是SOAR的程序。没有长期的程序性知识的情况下，Soar架构不能解决任何问题。(请注意“Soar架构”和
“SOAR程序”:前者是指本手册中所描述的系统，通用到
所有用户，后者指的是添加到体系结构中的知识。

Soar程序包含了用于解决特定任务(或一组任务)的知识，
包括关于如何选择和应用运算符来转换的状态的信息
问题，以及认识到目标已经实现的方法。

#### 2.1.1 Types of Procedural Knowledge in Soar

4中不同的类型

* 1，推理规则
在SOAR中，我们称这些为状态描述。这种知识提供单调的推论
在给定的情况下，可以对状态进行这样的处理。由这些规则创造的知识不是持久的，只有在满足规则的条件时才存在。

* 2，操作建议知识

关于操作何时适合于某种情况的知识。请注意在给定的上下文中，多个操作符可能是合适的。所以，SOAR也需要知识，以确定从候选中挑选哪些:

* 3，操作选择知识
该知识是关于操作在特定情况下可取性的期望值大小。以便于从（如该情况下，不要选择某操作）或（该情况倾向于选择什么操作）

* 4， ？？
操作如何对状态进行改变

#### 2.1.2 Problem-Solving Functions in Soar
这些问题解决函数是生成与之相关的行为的基本类型
现状:阐述现状，提出候选操作，比较
通过修改状态来应用操作符。这些功能是
通过SOAR程序编码的知识驱动的。
#### 2.1.3 An Example Task: The Blocks-World

在本手册中，我们将使用一个称为块世界的任务作为例子。在
块世界任务，初始状态有三个块命名为A, B, C在一个表上;的
操作符一次移动一个块到另一个位置(在另一个块的顶部或上
表);我们的目标是建造一座塔，塔顶是a，塔中是B，塔底是C
#### 2.1.4 Representation of States, Operators, and Goals
目标是显式或隐式
#### 2.1.5 Proposing candidate operators

提出候选操作
#### 2.1.6 Comparing candidate operators: Preferences

Soar选择操作的第二步是评估或比较候选操作符。在Soar中，这是通过规则来完成的，这些规则测试了被提议的操作和当前的状态，然后创建首选项(存储在首选项内存中)。偏好断言
候选操作符的相对优点或绝对优点。例如，一个偏好可能会说
在这个特定的时间，操作符A是比操作符B“更好”的选择，或者说是一种偏好
可能会说操作员A是在这个特定时间做的“最好”的事情
#### 2.1.7 Selecting a single operator: Decision

Soar尝试根据可用的首选项选择单个操作符作为决策
候选人运营商。可能会出现四种不同的情况:
1. 可用的首选项显然更喜欢单个操作符。
2. 可用的首选项建议使用多个操作符，并且更喜欢一个可以是多个操作符的子集
从随机选择的。
3.可用的首选项建议使用多个操作符，但上述情况1或2都不适用。
4. 可用的首选项不建议任何操作符。
在第一种情况下，首选操作符被选中。在第二种情况下，一个子集是
随机选择。在第三和第四宗案件中，SOAR陷入了僵局
求解，并创建一个新的子状态。第2.7节讨论了阻塞。
在我们的块世界示例中，第二种情况成立，Soar可以选择其中一个操作符
随机。

#### 2.1.8 Applying the operator 

操作符通过被应用来改变状态;适当的特定更改取决于操作符和当前状态。有两种主要的方法来改变状态:间接的和直接的。
在与外部环境交互的Soar程序中使用间接更改:Soar程序向外部环境发送电机命令，并监视外部环境的更改。这些从传感器收集到的变化反映在更新状态描述中Soar也可以直接改变状态;这些对应着SOAR“在头脑中”解决问题。Soar程序不与外部环境交互，只能直接改变状态。内部和外部问题的解决不应该被看作是soar中相互排斥的活动。与外部环境交互的Soar程序通常具有对状态进行直接或间接更改的操作符:motor命令表示为状态的子结构，它是对环境的命令。此外，一个Soar计划可以维护一个内部模型，该模型可以预测外部操作员如何修改世界;如果是，操作符必须更新内部模型(即状态的子结构)。
当Soar在进行内部问题解决时，它必须知道如何在应用操作符时适当地修改状态描述。如果它在外部环境中解决问题，它必须知道它可以发出什么可能的电机命令来影响它的环境

这里描述的示例块世界任务不与外部环境交互。因此，当应用操作符时，Soar程序直接更改状态。当一个块在我们的任务中移动时，可能需要做四个更改:
1. 正在移动的块不再是它原来的位置(它不再是“on top”of)
同样的事情)。
2. 正在移动的块位于一个新位置(它位于新事物的“顶部”)。
3.那块石头原来所在的地方现在已经清除了。
4. 块移动到的位置不再清楚—除非它是table，否则
通常被认为是“clear”。
块世界任务也可以使用外部模拟器来实现。在这种情况下,SOAR程序不更新所有的“在上”和“clear”的关系;更新后的状态描述来自模拟器。

#### 2.1.9 Making inferences about the state

对状态进行单调的推论是SOAR长期程序性知识可能扮演的另一个角色。这种描述知识可以简化操作符的编码，因为不必在操作符的应用程序中显式地包含状态的一组核心特性。在Soar中，当情况发生变化，推论不再成立时，这些推论会自动撤销。
例如，我们的示例块世界任务使用细化来跟踪一个块是否“清除”。描述测试特定块的“顶部”是否没有块;如果没有这样的“顶部”，块就是“清除”。当一个操作符应用程序创建一个新的“on top”时，相应的描述会取消，而块不再是“clear”。

#### 2.1.10 Problem Spaces

如果我们要建立一个翱翔的系统，在大量不同的类型上工作
问题是，我们需要在我们的Soar计划中包括大量的操作员。为
一个特定的问题和解决问题的特定阶段，只是所有可能的子集
操作符实际上是相关的。例如，如果我们的目标是计算表上的块，
操作人员必须移动块可能不重要，虽然他们可能
仍然是“法律”。与当前问题解决活动相关的操作符定义
在解决一个问题时可能考虑的状态的空间，即它们
定义问题空间。

对于提议经营者将限制经营者只考虑当它是相关的。
blocks世界的完整问题空间如图2.6所示。通常，当Soar解决了这个问题空间中的一个问题时，它不会显式地生成所有的状态，
检查它们，然后创建一个路径。相反，Soar在给定的时间处于特定的状态(在工作内存中表示)，试图选择一个将其移动到新状态的操作符。在当前的情况下，它使用关于选择操作符的所有知识，如果它的知识足够，它将朝着目标前进。同样的问题可以在Soar中被重新定义为一个规划问题，其目标是开发一个解决问题的计划，而不仅仅是解决问题。在这种情况下，Soar中的一个状态将由一个计划组成，该计划将依次拥有来自原始空间的块世界状态和操作符的表示。操作员将对计划执行编辑操作，如添加新的块世界操作员、模拟这些操作员等。
在两种问题的表述中，Soar仍然在应用运算符生成新的状态，只是状态和运算符的内容不同。
本章剩下的部分描述了Soar的记忆和过程:工作记忆，生产记忆，偏好记忆，Soar的执行周期(决策过程)，学习，以及输入和输出是如何适应的。

### 2.2 Working memory: The Current Situation

Soar在它的工作记忆中代表了当前解决问题的情况。因此，工作记忆持有当前的状态和操作者，是Soar的“短期”知识，反映了当前的世界知识和解决问题的状态。
工作记忆包含工作记忆元素，简称WMEs。每个WME包含一个非常具体的信息;例如，WME可能会说“B1是块”。多个WMEs共同可以提供关于同一对象的更多信息，如“B1是块”、“B1被命名为a”、“B1在桌子上”等。这些WMEs是相关的，因为它们都有助于描述某种内部称为“B1”的东西。B1称为标识符;共享这个标识符的一组WMEs在工作内存中称为一个对象。每个WME描述对象的不同属性，例如，它的名称、类型或位置;每个属性都有一个与之相关联的值，例如，名称是a，类型是block，位置在表上。因此，每个WME是一个identity -attribute-value三元组，所有具有相同标识符的WME都是同一对象的一部分。
工作内存中的对象被链接到其他对象:一个WME的值可能是另一个对象的标识符。例如，一个WME可能会说“B1在T1之上”，而另一个WMEs集合可能会描述对象T1:“T1是一个表”，“T1是棕色的”，“T1在F1之上”。另一个WMEs集合可能描述对象F1:“F1是一个层”，等等。工作内存中的所有对象都必须直接或间接(通过其他对象)链接到某个状态。没有连接到状态的对象将被Soar架构自动从工作内存中删除。
WMEs也经常被称为扩充，因为它们“扩充”了对象，提供了关于它的更多细节。虽然这两个术语有点多余，但WME是一个更常用来表示工作内存内容的术语(作为单个标识符-属性-值三元组)，而augmentality是一个更常用来表示对象描述的术语。工作记忆在第9页的图2.3中以抽象的层次进行了说明。
增加的属性通常是一个常量，例如“name”或“type”，因为
在某种意义上，属性只是用来区分工作内存中的某个链接的标签
另一个地方。2
增加的值可以是常量(如“red”)，也可以是标识符(如)
06。当值是一个标识符时，它引用工作内存中的一个对象
有额外的子结构。在语义网术语中，如果一个值是常量，那么它就是a
没有链路的终端节点;如果它是一个标识符，它就是一个非终端节点。

Soar的一个关键概念是工作记忆是一个集合，这意味着在工作记忆中不可能有两个元素同时拥有相同的identity -attribute-value三元组(这被架构所阻止)。但是，可以有多个工作内存元素，它们具有相同的标识符和属性，但是每个工作内存元素具有不同的值。当这种情况发生时，我们说属性是一个多值属性，通常简称为多属性。
对象是由其扩展定义的，而不是由其标识符定义的。标识符只是一个指向对象的标签或指针。在相同的Soar程序的后续运行中，可能会有一个对象具有完全相同的扩展，但是不同的标识符，程序仍然会对该对象进行适当的推理。标识符是Soar的内部标记;它们可以出现在工作记忆中，但不会出现在产品中。
工作内存中的对象和外部世界中的“真实对象”之间没有预定义的关系。工作记忆中的对象可以指真实的对象，如块A;物体的特征，如红色或形状立方体;对象之间的关系，如ontop;对象的类，如块;等。属性和值的实际名称对Soar架构没有任何意义(除了架构本身创建的几个WMEs之外)。举个例子，苏雅不在乎积木世界里的东西叫“积木”、“立方体”还是“枝形吊灯”。应该由Soar程序员来选择合适的标签并始终如一地使用它们。
工作记忆的要素有以下四种来源:
1. Productions:对Productions的RHS的操作创建了大多数工作内存元素。
2. 架构:
(a)状态增强:无论何时创建状态，决策过程都会自动创建一些特殊的状态增强(类型、超状态、僵局……)。
状态是在初始化期间(第一个状态)或由于陷入僵局(子状态)而创建的。
(b)操作员扩充:决策程序根据喜好创造操作员扩充状态。这将记录当前操作符的选择。
3.内存系统
4. sv
5. 环境:外部I/O系统在输入链路上为感官数据创建工作内存元素。
工作记忆中的元素以六种不同的方式去除:
1. 决策过程在导致创建状态扩展的僵局得到解决时，将自动删除它所创建的所有状态扩展。
2. 当不再选择该操作符作为当前操作符时，决策过程将移除状态的操作符扩展。
3.使用拒绝首选项的生产操作将删除由其他产品创建的工作内存元素。
4. 当创建它们的结果不再匹配时，体系结构将自动删除i支持的WMEs。
5. 当输入链接不再有效时，I/O系统将从输入链接中删除感官数据。
6. 体系结构会自动删除不再链接到某个状态的WME(因为已经删除了其他一些WME)。

在大多数情况下，用户可以自由使用适合任务的任何属性和值。然而，州有特殊的扩充，不能被规则直接创建、删除或修改。这包括在创建状态时创建的扩展，以及表示当前操作符的状态操作符扩展(并根据首选项创建)。第3.4节列出了Soar架构自动创建的特定属性。结果可以为状态创建任何其他属性。
首选项保存在一个单独的首选项内存中，在这里它们不能被产品测试。有一个明显的例外。由于soar程序可能需要对候选操作符进行推理，所以工作内存中也提供了可接受的首选项。可接受的首选项可以由结果进行测试，这允许Soar程序对候选操作符进行推理，以确定应该选择哪个操作符。偏好记忆和不同类型的偏好将在第2.4节中讨论。
### 2.3 Production Memory: Long-term Procedural Knowledge

明日回天津，再说。至少应该达到把例子运行一波的程度。